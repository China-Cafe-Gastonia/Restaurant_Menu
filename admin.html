<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Admin console for managing China Cafe restaurant menu">
    <meta name="robots" content="noindex, nofollow">
    <title>Admin Console - China Cafe Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
</head>
<body class="bg-gray-100 text-gray-800">
    <!-- Skip to main content link for keyboard/screen reader users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Navigation Menu -->
    <nav class="bg-white shadow-md sticky top-0 z-50" role="navigation" aria-label="Main navigation">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-2">
                    <span class="text-2xl" aria-hidden="true">üîê</span>
                    <span class="font-bold text-xl text-gray-800">Admin Console</span>
                </div>
                <div class="flex space-x-4">
                    <a href="index.html" class="text-gray-600 px-3 py-2 rounded hover:bg-gray-100 transition-colors">
                        <span aria-hidden="true">üìã</span> Public Menu
                    </a>
                    <a href="admin.html" class="text-blue-600 font-semibold px-3 py-2 rounded hover:bg-blue-50 transition-colors" aria-current="page">
                        <span aria-hidden="true">üîê</span> Admin
                    </a>
                </div>
            </div>
        </div>
    </nav>


    <!-- Login Form (centered vertically) -->
    <div id="loginContainer" class="flex items-center justify-center min-h-screen login-container">
        <div id="loginCard" class="card" role="region" aria-labelledby="login-heading">
            <h2 id="login-heading" class="text-2xl font-semibold mb-4">Admin Login</h2>
            <form id="loginForm" class="space-y-4" aria-label="Login form">
                <div>
                    <label for="adminEmail" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="adminEmail" required autocomplete="email" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                </div>
                <div>
                    <label for="adminPassword" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="adminPassword" required autocomplete="current-password" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                </div>
                <button type="submit" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-full shadow-md hover:bg-blue-700 transition-colors w-full">Login</button>
            </form>
            <div id="loginStatus" class="mt-4 text-sm font-medium" role="status" aria-live="polite"></div>
        </div>
    </div>

    <!-- Admin UI (hidden until logged in) -->
    <main id="main-content">
    <div id="adminMain" class="admin-main-hidden" role="region" aria-label="Admin controls">

        <!-- Field/Form 1: Menu Management Controls -->
        <div id="adminControls" class="card mb-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">Menu Management</h2>
                <div class="flex gap-2 items-center">
                    <button id="deleteButton" class="bg-red-500 text-white font-semibold py-1 px-4 rounded-full shadow hover:bg-red-600">Reset Private</button>
                    <button id="deletePublicButton" class="bg-red-400 text-white font-semibold py-1 px-4 rounded-full shadow hover:bg-red-500">Reset Public</button>
                    <button id="logoutButton" class="bg-gray-300 text-gray-800 font-semibold py-1 px-4 rounded-full shadow hover:bg-gray-400">Logout</button>
                </div>
            </div>
            <div class="mb-4">
                <label for="jsonFile" class="block text-sm font-medium text-gray-700">Select Menu: JSON File</label>
                <input type="file" id="jsonFile" accept=".json" class="mt-1 block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700
                    hover:file:bg-blue-100">
            </div>
            <div class="flex space-x-4 mb-4">
                <button id="uploadButton" class="bg-orange-500 text-white font-semibold py-2 px-6 rounded-full shadow-md hover:bg-orange-600 transition-colors">
                    Upload Menu
                </button>
                <button id="loadMenuButton" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-full shadow-md hover:bg-blue-600 transition-colors">
                    Load Menu
                </button>
                <button id="publishButton" class="bg-green-500 text-white font-semibold py-2 px-6 rounded-full shadow-md hover:bg-green-600 transition-colors">
                    Publish to Public Menu
                </button>
            </div>
                <div class="flex items-center gap-3">
                    <input type="checkbox" id="skipNormalizationToggle" />
                    <label for="skipNormalizationToggle" class="text-sm text-gray-700">Skip normalization (assume JSON already flattened)</label>
                    <span title="If checked, admin actions will NOT auto-convert legacy nested 'unit' arrays into objects; only enable if you always use flattened JSON." class="ml-2 text-gray-400">‚ÑπÔ∏è</span>
                    <button id="normalizeDownloadBtn" class="ml-4 bg-indigo-500 text-white font-semibold py-1 px-3 rounded-full shadow hover:bg-indigo-600">Normalize &amp; Download JSON</button>
                    <button id="downloadPrivateBtn" class="ml-2 bg-gray-700 text-white font-semibold py-1 px-3 rounded-full shadow hover:bg-gray-800">Download Private JSON</button>
                    <button id="downloadPublicBtn" class="ml-2 bg-gray-600 text-white font-semibold py-1 px-3 rounded-full shadow hover:bg-gray-700">Download Public JSON</button>
                </div>
            <div id="statusMessage" class="mt-6 text-sm font-medium"></div>
        </div>

        <!-- Field/Form 2: Editable Menu UI (like index.html, but editable) -->
        <div id="adminEditableMenu" class="mb-4">
            <div class="container mt-8">
                <header class="text-center mb-8">
                    <input id="editRestaurantName" type="text" class="text-4xl font-extrabold text-gray-900 w-full mb-2 bg-gray-50 rounded px-2 py-1 text-center" placeholder="Restaurant Name" />
                    <div id="editRestaurantInfo" class="text-lg text-gray-600 mt-2 flex flex-col items-center">
                        <input id="editRestaurantAddress" type="text" class="block w-full text-lg text-gray-700 bg-gray-50 rounded px-2 py-1 mb-1 max-w-xl" placeholder="Address" />
                        <input id="editRestaurantPhone" type="text" class="block w-full text-lg text-gray-700 bg-gray-50 rounded px-2 py-1 max-w-xl" placeholder="Phone" />
                        <div class="hours-block w-full flex flex-col items-center mt-2">
                            <div class="flex items-center mb-1">
                                <span class="hours-icon">üïí</span>
                                <span class="hours-title"><b>Hours:</b></span>
                            </div>
                            <div class="mb-2">
                                <label class="inline-flex items-center gap-2">
                                    <input id="useStructuredHours" type="checkbox" class="mr-2" />
                                    <span class="text-sm text-gray-600">Use structured hours (weekday open/close)</span>
                                </label>
                            </div>
                            <div id="structuredHours" class="w-full mb-2 structured-hours-hidden">
                                <div class="grid grid-cols-3 gap-2 text-sm text-gray-700 font-semibold mb-1"><div>Day</div><div>Open</div><div>Close</div></div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Monday">
                                    <div class="text-sm">Monday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Tuesday">
                                    <div class="text-sm">Tuesday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Wednesday">
                                    <div class="text-sm">Wednesday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Thursday">
                                    <div class="text-sm">Thursday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Friday">
                                    <div class="text-sm">Friday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Saturday">
                                    <div class="text-sm">Saturday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="grid grid-cols-3 gap-2 items-center mb-1 structured-hour-row" data-day="Sunday">
                                    <div class="text-sm">Sunday</div>
                                    <div><input type="time" class="hours-open block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="09:00" /></div>
                                    <div><input type="time" class="hours-close block w-full rounded px-2 py-1 bg-gray-50 text-sm" placeholder="17:00" /></div>
                                </div>
                                <div class="text-xs text-gray-500 mb-1">Leave both open/close blank to mark Closed.</div>
                            </div>
                            <div id="editHoursLines" class="hours-lines w-full flex flex-col items-center"></div>
                        </div>
                    </div>
                    <div id="editRestaurantNotes" class="mt-4 flex flex-col items-center">
                        <textarea id="editComboNote" class="w-full bg-yellow-50 border-l-4 border-yellow-400 rounded-lg p-2 mb-2 text-base text-red-700 font-semibold max-w-xl" rows="2" placeholder="Combo Plate Note"></textarea>
                        <textarea id="editLunchNote" class="w-full bg-yellow-50 border-l-4 border-yellow-400 rounded-lg p-2 text-base text-blue-700 font-semibold max-w-xl" rows="2" placeholder="Lunch Special Note"></textarea>
                        <div class="mt-3">
                            <button id="saveInfoBtn" class="bg-indigo-600 text-white font-semibold py-1 px-4 rounded-full shadow-md hover:bg-indigo-700">Save Info</button>
                        </div>
                    </div>
                </header>
                <div id="loadingMessage" class="text-center text-gray-500 text-lg">Loading menu...</div>
                <div id="menuContainer"></div>
            </div>
        </div>

        <!-- Save Menu Button (hidden by default, shown when menu is edited) -->
        <div class="flex justify-end mb-4 save-menu-hidden" id="saveMenuBtnRow">
            <button id="saveMenuBtn" class="bg-green-600 text-white font-bold py-2 px-8 rounded-full shadow hover:bg-green-700">Save Menu</button>
        </div>

        <!-- Confirmation Modal for Save -->
        <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center confirm-modal">
            <div class="bg-white rounded-lg p-6 w-96 shadow-lg">
                <h3 class="text-lg font-semibold mb-3">Confirm Save</h3>
                <p class="text-sm text-gray-700 mb-4">This will update the private menu. Do you want to continue?</p>
                <div class="flex justify-end gap-3">
                    <button id="confirmCancelBtn" class="px-3 py-1 rounded bg-gray-200">Cancel</button>
                    <button id="confirmSaveBtn" class="px-3 py-1 rounded bg-green-600 text-white">Save</button>
                </div>
            </div>
        </div>

        <!-- Field/Form 3: Output Box (always visible, toggle with arrow) -->
        <div id="outputBox" class="card output-box">
            <div class="flex items-center justify-between mb-2 relative">
                <h2 class="text-xl font-semibold mb-0">Output</h2>
                <button id="toggleOutputBtn" class="absolute top-1/2 right-0 -translate-y-1/2 bg-white rounded-full shadow px-2 py-1 text-gray-500 hover:text-gray-800 text-2xl focus:outline-none border border-gray-200 toggle-output-btn" title="Show/Hide Output">
                    <span id="outputArrow">‚ñº</span>
                </button>
            </div>
            <div id="statusOutput" class="bg-gray-100 border rounded p-2 font-mono text-sm text-gray-700 status-output" role="log" aria-live="polite"></div>
        </div>
        <!-- Floating outputArrow for when output box is hidden -->
        <button id="floatingOutputArrow" class="fixed right-4 bottom-2 bg-white rounded-full shadow px-2 py-1 text-gray-500 hover:text-gray-800 text-2xl focus:outline-none border border-gray-200 floating-output-arrow" title="Show Output" aria-label="Show output panel">
            <span aria-hidden="true">‚ñ≤</span>
        </button>
    </div>
    </main>

    <script type="module">
    // Output box toggle logic (slide down/up) and logStatus helper
    window.addEventListener('DOMContentLoaded', () => {
        const outputBox = document.getElementById('outputBox');
        const toggleOutputBtn = document.getElementById('toggleOutputBtn');
        const outputArrow = document.getElementById('outputArrow');
        const floatingOutputArrow = document.getElementById('floatingOutputArrow');
        const statusOutput = document.getElementById('statusOutput');
        let outputHidden = false;
        function showOutputBox() {
            outputBox.style.transform = 'translateY(0)';
            outputArrow.textContent = '‚ñº';
            floatingOutputArrow.style.display = 'none';
            outputHidden = false;
        }
        function hideOutputBox() {
            outputBox.style.transform = 'translateY(90%)';
            outputArrow.textContent = '‚ñ≤';
            floatingOutputArrow.style.display = '';
            outputHidden = true;
        }
        toggleOutputBtn.addEventListener('click', () => {
            if (outputHidden) {
                showOutputBox();
            } else {
                hideOutputBox();
            }
        });
        floatingOutputArrow.addEventListener('click', showOutputBox);
        // Ensure output box starts visible
        showOutputBox();

        // logStatus helper: always append to output box
        window.logStatus = function(msg) {
            if (!statusOutput) return;
            const now = new Date();
            const time = now.toLocaleTimeString();
            statusOutput.textContent += `[${time}] ${msg}\n`;
            statusOutput.scrollTop = statusOutput.scrollHeight;
            // Hide loading message if present
            const loadingMsg = document.getElementById('loadingMessage');
            if (loadingMsg) loadingMsg.style.display = 'none';
        };
    });

    // --- All DOM-dependent logic must run after DOMContentLoaded ---
    window.addEventListener('DOMContentLoaded', () => {
    });
    // Wire up structured hours toggle
    window.addEventListener('DOMContentLoaded', () => {
        const useStructured = document.getElementById('useStructuredHours');
        const structuredBlock = document.getElementById('structuredHours');
        const hoursLines = document.getElementById('editHoursLines');
        if (useStructured && structuredBlock) {
            useStructured.addEventListener('change', () => {
                if (useStructured.checked) {
                    structuredBlock.style.display = '';
                    // clear free-text lines area
                    if (hoursLines) hoursLines.innerHTML = '';
                } else {
                    structuredBlock.style.display = 'none';
                }
            });
        }
    });
    
    // Import Firebase configuration and utilities
    import { db, auth, appId } from './js/firebase-config.js';
    import { collection, getDocs, writeBatch, doc } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
    import { signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
    
    // Import utility functions
    import { flattenUnitField, normalizeWholeDoc, normalizeMenuItem } from './js/utils/normalize.js';
    import { formatPrice, to12Hour, normalizeIngredientToken, normalizeIngredientName } from './js/utils/formatters.js';
    import { setupGlobalErrorHandlers, logError, logInfo, logWarning, showNotification } from './js/utils/error-handling.js';
    import { escapeHtml, escapeAttr } from './js/utils/sanitize.js';
    import { setButtonLoading } from './js/utils/ui-helpers.js';

    // Initialize global error handlers
    setupGlobalErrorHandlers();

    // Keep last parsed/uploaded or loaded doc in memory so "Normalize & Download" can use it
    let lastParsedDoc = null;

    // Skip normalization when admin chooses to (persisted in localStorage)
        const SKIP_KEY = 'skipNormalization';
        // Restore toggle value on page load
        window.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('skipNormalizationToggle');
            try {
                const val = localStorage.getItem(SKIP_KEY);
                toggle.checked = val === '1';
            } catch (e) {
                // ignore storage errors
            }
            toggle.addEventListener('change', () => {
                try {
                    localStorage.setItem(SKIP_KEY, toggle.checked ? '1' : '0');
                    logStatus(`Skip normalization set to: ${toggle.checked}`);
                } catch (e) {
                    console.warn('Failed to persist skipNormalization setting', e);
                }
            });
        });

        // Normalize a full menu document (either the original backup shape or the Firestore-friendly flattened list)
        // Note: normalizeWholeDoc is now imported from js/utils/normalize.js
        
        function downloadJson(obj, filename) {
            const dataStr = JSON.stringify(obj, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'menu.normalized.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        // Wire Normalize & Download button
        window.addEventListener('DOMContentLoaded', () => {
            const btn = document.getElementById('normalizeDownloadBtn');
            btn.addEventListener('click', () => {
                const src = lastParsedDoc || null;
                if (!src) {
                    logStatus('No parsed menu available to normalize. Please upload a file or load the private menu first.');
                    return;
                }
                const normalized = normalizeWholeDoc(src);
                downloadJson(normalized, 'menu.normalized.json');
                logStatus('Prepared normalized JSON and started download.');
            });
            // Download current private dataset from Firestore
            const downloadPrivateBtn = document.getElementById('downloadPrivateBtn');
            downloadPrivateBtn.addEventListener('click', async () => {
                if (!db || !auth.currentUser) {
                    logStatus('You must be logged in as admin.');
                    return;
                }
                try {
                    logStatus('Fetching PRIVATE menu from Firestore...');
                    const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
                    const snap = await getDocs(menuRef);
                    if (snap.empty) {
                        logStatus('No private menu data found.');
                        return;
                    }
                    const items = [];
                    let info = null;
                    snap.forEach(docSnap => {
                        if (docSnap.id === '_info') info = docSnap.data();
                        else items.push({ _id: docSnap.id, ...docSnap.data() });
                    });
                    // Normalize unless skipped
                    const skip = (() => { try { return localStorage.getItem(SKIP_KEY) === '1'; } catch (e) { return false; }})();
                    const out = {
                        generatedAt: new Date().toISOString(),
                        info: info || {},
                        menu: skip ? items : items.map(normalizeMenuItem)
                    };
                    downloadJson(out, `menu_private_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`);
                    logStatus('Private menu downloaded.');
                } catch (e) {
                    console.error(e);
                    logStatus('Error downloading private menu: ' + (e.message || e));
                }
            });
            // Download current public dataset from Firestore
            const downloadPublicBtn = document.getElementById('downloadPublicBtn');
            downloadPublicBtn.addEventListener('click', async () => {
                try {
                    logStatus('Fetching PUBLIC menu from Firestore...');
                    const menuRef = collection(db, `artifacts/${appId}/public/data/menu_data`);
                    const snap = await getDocs(menuRef);
                    if (snap.empty) {
                        logStatus('No public menu data found.');
                        return;
                    }
                    const items = [];
                    let info = null;
                    snap.forEach(docSnap => {
                        if (docSnap.id === '_info') info = docSnap.data();
                        else items.push({ _id: docSnap.id, ...docSnap.data() });
                    });
                    const skip = (() => { try { return localStorage.getItem(SKIP_KEY) === '1'; } catch (e) { return false; }})();
                    const out = {
                        generatedAt: new Date().toISOString(),
                        info: info || {},
                        menu: skip ? items : items.map(normalizeMenuItem)
                    };
                    downloadJson(out, `menu_public_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`);
                    logStatus('Public menu downloaded.');
                } catch (e) {
                    console.error(e);
                    logStatus('Error downloading public menu: ' + (e.message || e));
                }
            });
        });

        // Note: normalizeMenuItem is now imported from js/utils/normalize.js

        // Note: normalizeIngredientName is now imported from js/utils/formatters.js

        // Build admin-friendly HTML for an item with editable fields
        function buildAdminItemHtml(item) {
            // item is normalized (unit array of {size, option, price})
            const name = item.name || '';
            const desc = item.description || '';
            const units = Array.isArray(item.unit) ? item.unit : [];
            // Group by size
            const groups = units.reduce((acc, u) => {
                const key = u && typeof u === 'object' ? String(u.size || '') : String(u || '');
                (acc[key] = acc[key] || []).push(u);
                return acc;
            }, {});
            const unitHtml = Object.entries(groups).map(([size, opts]) => {
                const hasOptions = opts.some(o => o && typeof o === 'object' && o.option);
                    if (hasOptions) {
                    const optsHtml = opts.map(u => `
                        <div class="admin-unit-row admin-unit-option flex items-center gap-3 mb-0.5">
                            <input type="hidden" class="admin-unit-size" value="${escapeAttr(size)}" />
                            <input type="text" class="text-sm text-gray-700 bg-gray-50 rounded px-2 py-1 w-40 admin-unit-option-input" value="${escapeAttr(u.option || '')}" placeholder="Option" />
                            <input type="text" class="w-20 bg-gray-50 rounded px-2 py-1 text-orange-600 font-semibold admin-unit-price-input" value="${escapeAttr(u.price || '')}" placeholder="Price" />
                        </div>`).join('');
                    return `
                        <div class="mb-1 admin-unit-group">
                            ${size ? `<div class="text-sm font-semibold text-gray-800 mb-0.5">${escapeHtml(size)}</div>` : ''}
                            ${optsHtml}
                        </div>`;
                }
                // No options: show size with price(s)
                const rows = opts.map(u => `
                    <div class="admin-unit-row admin-unit-simple flex items-center gap-3 mb-0.5">
                        <input type="text" class="text-sm text-gray-700 bg-gray-50 rounded px-2 py-1 w-28 admin-unit-size-input" value="${escapeAttr(size)}" placeholder="Size" />
                        <input type="text" class="w-20 bg-gray-50 rounded px-2 py-1 text-orange-600 font-semibold admin-unit-price-input" value="${escapeAttr(u && u.price ? u.price : '')}" placeholder="Price" />
                    </div>`).join('');
                return `<div class="mb-1 admin-unit-group">${rows}</div>`;
            }).join('');
            return `
                <li class="border-b pb-2 admin-item">
                    <div class="flex items-start gap-3">
                        <div class="flex-shrink-0 mt-1">
                            <label class="inline-flex items-center text-sm">
                                <input type="checkbox" class="admin-item-spicy mr-2" ${item.spicy ? 'checked' : ''} />
                                <span class="text-sm text-gray-600">Spicy</span>
                            </label>
                        </div>
                        <div class="flex-grow">
                            <input type="hidden" class="admin-item-id" value="${escapeAttr(item._id || '')}" />
                            <input type="text" class="text-lg font-semibold bg-gray-50 rounded px-2 py-1 mb-1 w-full admin-item-name ${item.spicy ? 'is-spicy' : ''}" value="${escapeAttr(name)}" />
                            <input type="text" class="text-sm text-gray-500 bg-gray-50 rounded px-2 py-1 mb-1 w-full admin-item-desc" value="${escapeAttr(desc)}" />
                            <textarea class="text-sm text-gray-600 bg-gray-50 rounded px-2 py-1 mb-1 w-full admin-item-ingredients" placeholder="Ingredients (comma or newline separated)">${escapeHtml(Array.isArray(item.ingredients) ? item.ingredients.join(', ') : (item.ingredients || ''))}</textarea>
                            ${unitHtml}
                        </div>
                    </div>
                </li>`;
        }
        // UI elements
        const loginCard = document.getElementById('loginCard');
        const loginForm = document.getElementById('loginForm');
        const loginStatus = document.getElementById('loginStatus');
        const adminCard = document.getElementById('adminCard');
        const uploadButton = document.getElementById('uploadButton');
        const deleteButton = document.getElementById('deleteButton');
    const logoutButton = document.getElementById('logoutButton');
    const deletePublicButton = document.getElementById('deletePublicButton');
        const statusMessage = document.getElementById('statusMessage');
        const jsonFile = document.getElementById('jsonFile');

        // Auth state observer
        onAuthStateChanged(auth, (user) => {
            const infoCard = document.getElementById('restaurantInfoCard');
            if (user) {
                // Show admin UI and info card
                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('adminMain').style.display = '';
                if (infoCard) infoCard.style.display = '';
                statusMessage.textContent = 'Firebase initialized. Ready.';
                if (typeof logStatus === 'function') logStatus('Firebase initialized. Ready.');
            } else {
                // Show login UI only
                document.getElementById('loginContainer').style.display = '';
                document.getElementById('adminMain').style.display = 'none';
                if (infoCard) infoCard.style.display = 'none';
                loginStatus.textContent = '';
                statusMessage.textContent = '';
                if (typeof logStatus === 'function') logStatus('Logged out or not authenticated.');
            }
        });

        // Login form submit
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const emailInput = document.getElementById('adminEmail');
            const passwordInput = document.getElementById('adminPassword');
            const email = emailInput.value;
            const password = passwordInput.value;
            loginStatus.textContent = 'Logging in...';
            loginStatus.style.color = '#2563eb';
            loginStatus.style.display = 'block';
            if (typeof logStatus === 'function') logStatus('Logging in...');
            (async () => {
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    loginStatus.textContent = 'Login successful!';
                    loginStatus.style.color = '#16a34a'; // green
                    loginStatus.style.display = 'block';
                    if (typeof logStatus === 'function') logStatus('Login successful!');
                    // Only clear fields on success
                    setTimeout(() => {
                        loginStatus.textContent = '';
                        emailInput.value = '';
                        passwordInput.value = '';
                    }, 1500);
                } catch (error) {
                    loginStatus.textContent = 'Login failed: ' + (error.message || error.code);
                    loginStatus.style.color = '#dc2626'; // red
                    loginStatus.style.display = 'block';
                    if (typeof logStatus === 'function') logStatus('Login failed: ' + (error.message || error.code));
                    // Do NOT clear fields on failure
                }
            })();
        });

        // Logout button
        logoutButton.addEventListener('click', async () => {
            await signOut(auth);
        });

        // Upload a JSON file to PRIVATE dataset
        uploadButton.addEventListener('click', async () => {
            if (!db || !auth.currentUser) {
                statusMessage.textContent = 'You must be logged in as admin.';
                return;
            }
            const file = jsonFile.files[0];
            if (!file) {
                statusMessage.textContent = 'Please select a JSON file to upload.';
                return;
            }
            setButtonLoading(uploadButton, true, 'Uploading...');
            logStatus('Uploading menu to PRIVATE dataset...');
            try {
                const fileReader = new FileReader();
                fileReader.onload = async (event) => {
                    let menuData;
                    try {
                        menuData = JSON.parse(event.target.result);
                        // keep original parsed doc for download/normalize
                        lastParsedDoc = menuData;
                    } catch (parseError) {
                        console.error("Error parsing JSON file:", parseError);
                        logStatus(`Error parsing JSON file: ${parseError.message}`);
                        setButtonLoading(uploadButton, false);
                        return;
                    }
                    let restaurantInfo = null;
                    let notesInfo = null;
                    // Accept both flat array and nested format
                    if (!Array.isArray(menuData)) {
                        if (menuData.menu && Array.isArray(menuData.menu)) {
                            if (menuData.restaurant) restaurantInfo = menuData.restaurant;
                            if (menuData.notes) notesInfo = menuData.notes;
                            menuData = menuData.menu.flatMap((cat, catIdx) =>
                                (cat.items || []).map((item, itemIdx) => ({
                                    ...item,
                                    category: cat.category,
                                    chinese_name: cat.chinese_name || '',
                                    note: cat.note || '',
                                    categoryOrder: catIdx,
                                    itemOrder: itemIdx
                                }))
                            );
                        } else {
                            logStatus('Error: The uploaded file is not a valid JSON array or menu format.');
                            setButtonLoading(uploadButton, false);
                            return;
                        }
                    } else {
                        menuData = menuData.map((item, idx) => ({ ...item, categoryOrder: 0, itemOrder: idx }));
                    }
                    try {
                        const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
                        const existingDocs = await getDocs(menuRef);
                        const deleteBatch = writeBatch(db);
                        existingDocs.forEach((doc) => {
                            deleteBatch.delete(doc.ref);
                        });
                        await deleteBatch.commit();
                        const newBatch = writeBatch(db);
                        if (restaurantInfo || notesInfo) {
                            const infoDocRef = doc(menuRef, '_info');
                            newBatch.set(infoDocRef, {
                                ...(restaurantInfo ? { restaurant: restaurantInfo } : {}),
                                ...(notesInfo ? { notes: notesInfo } : {})
                            });
                        }
                        menuData.forEach(item => {
                            const newItem = normalizeMenuItem(item);
                            const newDocRef = doc(menuRef);
                            newBatch.set(newDocRef, newItem);
                        });
                        await newBatch.commit();
                        logStatus(`Menu uploaded to PRIVATE dataset! Added ${menuData.length} items.`);
                        setButtonLoading(uploadButton, false);
                        document.getElementById('loadMenuButton').click();
                    } catch (uploadError) {
                        console.error("Error uploading menu:", uploadError);
                        logStatus(`Error uploading menu: ${uploadError.message}`);
                        setButtonLoading(uploadButton, false);
                    }
                };
                fileReader.readAsText(file);
            } catch (error) {
                console.error("Error uploading menu:", error);
                logStatus(`Error uploading menu: ${error.message}`);
                setButtonLoading(uploadButton, false);
            }
        });

                // Save Menu button: collect edits from admin UI and write to PRIVATE dataset
                const saveMenuBtn = document.getElementById('saveMenuBtn');
                const confirmModal = document.getElementById('confirmModal');
                const confirmCancelBtn = document.getElementById('confirmCancelBtn');
                const confirmSaveBtn = document.getElementById('confirmSaveBtn');

                saveMenuBtn.addEventListener('click', () => {
                    // show modal
                    confirmModal.style.display = '';
                });
                confirmCancelBtn.addEventListener('click', () => {
                    confirmModal.style.display = 'none';
                });

                confirmSaveBtn.addEventListener('click', async () => {
                    confirmModal.style.display = 'none';
                    if (!db || !auth.currentUser) {
                        logStatus('You must be logged in as admin.');
                        return;
                    }
                    setButtonLoading(saveMenuBtn, true, 'Saving...');
                    try {
                        logStatus('Preparing to save edited menu (upsert) to PRIVATE dataset...');

                        // Build items by iterating categories to capture ordering correctly
                        const menuContainer = document.getElementById('menuContainer');
                        const categoryCards = menuContainer.querySelectorAll('.menu-card');
                        const items = [];
                        let hasInvalid = false;
                        let firstInvalidEl = null;

                        categoryCards.forEach((card, catIdx) => {
                            const categoryName = (card.querySelector('.text-2xl')?.value || card.querySelector('input[type=text]')?.value || '').trim();
                            const itemEls = card.querySelectorAll('.admin-item');
                            itemEls.forEach((li, itemIdx) => {
                                const id = li.querySelector('.admin-item-id')?.value || null;
                                const name = li.querySelector('.admin-item-name')?.value || '';
                                const description = li.querySelector('.admin-item-desc')?.value || '';
                                // collect unit groups
                                const unit = [];
                                const groups = li.querySelectorAll('.admin-unit-group');
                                groups.forEach(g => {
                                    const sizeHeader = (g.querySelector('.text-sm.font-semibold')?.textContent || '').trim();
                                    const optionRows = g.querySelectorAll('.admin-unit-option');
                                    if (optionRows && optionRows.length) {
                                        optionRows.forEach(row => {
                                            const size = (row.querySelector('.admin-unit-size')?.value || sizeHeader || '').trim() || null;
                                            const opt = (row.querySelector('.admin-unit-option-input')?.value || '').trim() || null;
                                            const priceEl = row.querySelector('.admin-unit-price-input');
                                            const priceRaw = priceEl?.value ?? '';
                                            const price = priceRaw === null || priceRaw === '' ? null : Number(priceRaw);
                                            // validation: non-empty must be a finite number
                                            if (priceRaw !== '' && !Number.isFinite(Number(priceRaw))) {
                                                hasInvalid = true;
                                                if (priceEl) {
                                                    priceEl.style.border = '2px solid #f87171';
                                                    if (!firstInvalidEl) firstInvalidEl = priceEl;
                                                }
                                            } else if (priceEl) {
                                                // clear previous invalid styles
                                                priceEl.style.border = '';
                                            }
                                            unit.push({ size, option: opt, price });
                                        });
                                    } else {
                                        const simpleRows = g.querySelectorAll('.admin-unit-simple');
                                        simpleRows.forEach(sr => {
                                            const size = (sr.querySelector('.admin-unit-size-input')?.value || '').trim() || null;
                                            const priceEl = sr.querySelector('.admin-unit-price-input');
                                            const priceRaw = priceEl?.value ?? '';
                                            const price = priceRaw === null || priceRaw === '' ? null : Number(priceRaw);
                                            if (priceRaw !== '' && !Number.isFinite(Number(priceRaw))) {
                                                hasInvalid = true;
                                                if (priceEl) {
                                                    priceEl.style.border = '2px solid #f87171';
                                                    if (!firstInvalidEl) firstInvalidEl = priceEl;
                                                }
                                            } else if (priceEl) {
                                                priceEl.style.border = '';
                                            }
                                            unit.push({ size, option: null, price });
                                        });
                                    }
                                });

                                const spicy = !!li.querySelector('.admin-item-spicy')?.checked;
                                const ingredientsRaw = li.querySelector('.admin-item-ingredients')?.value || '';
                                const ingredients = (ingredientsRaw || '').split(/[\n,]/).map(s => s.trim()).filter(Boolean).map(normalizeIngredientName);
                                // dedupe while preserving order
                                const dedup = [];
                                const seen = new Set();
                                ingredients.forEach(i => {
                                    const key = i.toLowerCase();
                                    if (!seen.has(key)) { seen.add(key); dedup.push(i); }
                                });
                                items.push({ _id: id, name, description, unit, spicy, ingredients: dedup.length ? dedup : null, category: categoryName, categoryOrder: catIdx, itemOrder: itemIdx });
                            });
                        });

                        if (hasInvalid) {
                            logStatus('One or more price fields are invalid. Fix highlighted fields and retry save.');
                            if (firstInvalidEl && typeof firstInvalidEl.scrollIntoView === 'function') firstInvalidEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            setButtonLoading(saveMenuBtn, false);
                            return;
                        }

                        // Build info object from fields (include hours and both address/location for compatibility)
                        const info = {};
                        const restName = document.getElementById('editRestaurantName')?.value || '';
                        const restAddr = document.getElementById('editRestaurantAddress')?.value || '';
                        const restPhone = document.getElementById('editRestaurantPhone')?.value || '';
                        const combo = document.getElementById('editComboNote')?.value || '';
                        const lunch = document.getElementById('editLunchNote')?.value || '';
                        if (restName || restAddr || restPhone) {
                            const restaurantObj = { name: restName };
                            if (restAddr) { restaurantObj.address = restAddr; restaurantObj.location = restAddr; }
                            if (restPhone) restaurantObj.phone = restPhone;
                            // collect hours inputs (if any). If structured hours is enabled, collect weekday open/close
                            const useStructured = document.getElementById('useStructuredHours');
                            if (useStructured && useStructured.checked) {
                                const structuredBlock = document.getElementById('structuredHours');
                                if (structuredBlock) {
                                    const rows = structuredBlock.querySelectorAll('.structured-hour-row');
                                    const hoursObj = {};
                                    // validate time inputs
                                    const timeRegex = /^\d{2}:\d{2}$/;
                                    let firstInvalidTime = null;
                                    rows.forEach(r => {
                                        const day = r.getAttribute('data-day');
                                        const open = r.querySelector('.hours-open')?.value || '';
                                        const close = r.querySelector('.hours-close')?.value || '';
                                        // validate provided times (if any)
                                        const openVal = String(open || '').trim();
                                        const closeVal = String(close || '').trim();
                                        if (openVal && !timeRegex.test(openVal)) {
                                            firstInvalidTime = firstInvalidTime || r.querySelector('.hours-open');
                                            if (r.querySelector('.hours-open')) r.querySelector('.hours-open').style.border = '2px solid #f87171';
                                        } else if (r.querySelector('.hours-open')) r.querySelector('.hours-open').style.border = '';
                                        if (closeVal && !timeRegex.test(closeVal)) {
                                            firstInvalidTime = firstInvalidTime || r.querySelector('.hours-close');
                                            if (r.querySelector('.hours-close')) r.querySelector('.hours-close').style.border = '2px solid #f87171';
                                        } else if (r.querySelector('.hours-close')) r.querySelector('.hours-close').style.border = '';
                                        if (openVal || closeVal) {
                                            hoursObj[day] = { open: openVal, close: closeVal };
                                        }
                                    });
                                    if (firstInvalidTime) {
                                        hasInvalid = true;
                                        if (!firstInvalidEl) firstInvalidEl = firstInvalidTime;
                                    }
                                    if (Object.keys(hoursObj).length) restaurantObj.hours = hoursObj;
                                }
                            } else {
                                const hoursContainer = document.getElementById('editHoursLines');
                                if (hoursContainer) {
                                    const hourInputs = Array.from(hoursContainer.querySelectorAll('input')).map(i => i.value).map(s => String(s || '').trim()).filter(Boolean);
                                    if (hourInputs.length) restaurantObj.hours = hourInputs;
                                }
                            }
                            info.restaurant = restaurantObj;
                        }
                        if (combo || lunch) info.notes = { combination_plate: combo, lunch_special: lunch };

                        // Prepare Firestore refs
                        const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);

                        // Fetch existing docs to decide which to update/delete and to create a backup
                        const existingDocsSnap = await getDocs(menuRef);
                        const existingById = {};
                        const backupItems = [];
                        let existingInfo = null;
                        existingDocsSnap.forEach(ds => {
                            if (ds.id === '_info') {
                                existingInfo = ds.data();
                            } else {
                                existingById[ds.id] = ds.ref;
                                backupItems.push({ _id: ds.id, ...ds.data() });
                            }
                        });

                        // Download a JSON backup of the current private menu before making changes
                        try {
                            const backup = { exportedAt: new Date().toISOString(), appId: firebaseConfig.appId, info: existingInfo, menuData: backupItems };
                            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `menu_backup_private_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            URL.revokeObjectURL(url);
                            logStatus('Backup downloaded locally before saving changes.');
                        } catch (dlErr) {
                            console.warn('Failed to download backup before saving:', dlErr);
                            logStatus('Warning: failed to download backup before saving. Proceeding with save.');
                        }

                        // Perform upsert/delete with batch
                        const batch = writeBatch(db);
                        if (Object.keys(info).length) {
                            batch.set(doc(menuRef, '_info'), info);
                        }

                        items.forEach(it => {
                            let docRef;
                            if (it._id && existingById[it._id]) {
                                docRef = existingById[it._id];
                            } else if (it._id) {
                                docRef = doc(menuRef, it._id);
                            } else {
                                docRef = doc(menuRef);
                            }
                            const saveObj = normalizeMenuItem({ name: it.name, description: it.description, unit: it.unit, spicy: !!it.spicy, ingredients: it.ingredients || null, category: it.category || '', categoryOrder: it.categoryOrder || 0, itemOrder: it.itemOrder || 0 });
                            batch.set(docRef, saveObj);
                            if (docRef.id) delete existingById[docRef.id];
                        });

                        // Delete any remaining old docs that were removed
                        Object.values(existingById).forEach(ref => batch.delete(ref));
                        await batch.commit();
                        logStatus(`Saved ${items.length} items to PRIVATE dataset (upsert).`);
                        setButtonLoading(saveMenuBtn, false);
                        document.getElementById('loadMenuButton').click();
                    } catch (e) {
                        console.error(e);
                        logStatus('Error saving menu: ' + (e.message || e));
                        setButtonLoading(saveMenuBtn, false);
                    }
                });

    // Delete the entire PUBLIC menu from Firestore
    deletePublicButton.addEventListener('click', async () => {
        if (!db || !auth.currentUser) {
            statusMessage.textContent = 'You must be logged in as admin.';
            return;
        }
        setButtonLoading(deletePublicButton, true, 'Deleting...');
        try {
            logStatus('Deleting PUBLIC menu...');
            const menuRef = collection(db, `artifacts/${appId}/public/data/menu_data`);
            const existingDocs = await getDocs(menuRef);
            const deleteBatch = writeBatch(db);
            existingDocs.forEach((doc) => {
                deleteBatch.delete(doc.ref);
            });
            await deleteBatch.commit();
            logStatus('PUBLIC menu deleted successfully!');
            setButtonLoading(deletePublicButton, false);
        } catch (error) {
            console.error("Error deleting public menu:", error);
            logStatus(`Error deleting public menu: ${error.message}`);
            setButtonLoading(deletePublicButton, false);
        }
    });

            // Save Info (restaurant/notes) separately
            const saveInfoBtn = document.getElementById('saveInfoBtn');
            if (saveInfoBtn) {
                saveInfoBtn.addEventListener('click', async () => {
                    if (!db || !auth.currentUser) { logStatus('You must be logged in as admin.'); return; }
                    setButtonLoading(saveInfoBtn, true, 'Saving...');
                    try {
                        logStatus('Saving restaurant info...');
                        const restName = document.getElementById('editRestaurantName')?.value || '';
                        const restAddr = document.getElementById('editRestaurantAddress')?.value || '';
                        const restPhone = document.getElementById('editRestaurantPhone')?.value || '';
                        const combo = document.getElementById('editComboNote')?.value || '';
                        const lunch = document.getElementById('editLunchNote')?.value || '';
                        const info = {};
                        if (restName || restAddr || restPhone) {
                            const restaurantObj = { name: restName };
                            if (restAddr) { restaurantObj.address = restAddr; restaurantObj.location = restAddr; }
                            if (restPhone) restaurantObj.phone = restPhone;
                            // structured hours validation/collection
                            const useStructured = document.getElementById('useStructuredHours');
                            if (useStructured && useStructured.checked) {
                                const structuredBlock = document.getElementById('structuredHours');
                                if (structuredBlock) {
                                    const rows = structuredBlock.querySelectorAll('.structured-hour-row');
                                    const hoursObj = {};
                                    const timeRegex = /^\d{2}:\d{2}$/;
                                    let bad = null;
                                    rows.forEach(r => {
                                        const day = r.getAttribute('data-day');
                                        const open = r.querySelector('.hours-open')?.value || '';
                                        const close = r.querySelector('.hours-close')?.value || '';
                                        const openVal = String(open || '').trim();
                                        const closeVal = String(close || '').trim();
                                        if (openVal && !timeRegex.test(openVal)) bad = bad || r.querySelector('.hours-open');
                                        if (closeVal && !timeRegex.test(closeVal)) bad = bad || r.querySelector('.hours-close');
                                        if (openVal || closeVal) hoursObj[day] = { open: openVal, close: closeVal };
                                    });
                                    if (bad) { if (typeof bad.scrollIntoView === 'function') bad.scrollIntoView({behavior:'smooth', block:'center'}); bad.style.border='2px solid #f87171'; logStatus('Invalid time format in structured hours. Use HH:MM. Save aborted.'); setButtonLoading(saveInfoBtn, false); return; }
                                    if (Object.keys(hoursObj).length) restaurantObj.hours = hoursObj;
                                }
                            } else {
                                const hoursContainer = document.getElementById('editHoursLines');
                                if (hoursContainer) {
                                    const hourInputs = Array.from(hoursContainer.querySelectorAll('input')).map(i => i.value).map(s => String(s || '').trim()).filter(Boolean);
                                    if (hourInputs.length) restaurantObj.hours = hourInputs;
                                }
                            }
                            info.restaurant = restaurantObj;
                        }
                        if (combo || lunch) info.notes = { combination_plate: combo, lunch_special: lunch };
                        // write _info doc
                        const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
                        await writeBatch(db).set(doc(menuRef, '_info'), info).commit();
                        logStatus('Restaurant info saved.');
                        setButtonLoading(saveInfoBtn, false);
                        document.getElementById('loadMenuButton').click();
                    } catch (err) {
                        console.error(err);
                        logStatus('Error saving restaurant info: ' + (err.message || err));
                        setButtonLoading(saveInfoBtn, false);
                    }
                });
            }

    // Hide loading message after menu loads (if menu is loaded elsewhere, this should be called after render)
    function hideLoadingMessage() {
        const loadingMsg = document.getElementById('loadingMessage');
        if (loadingMsg) loadingMsg.style.display = 'none';
    }

    // --- MENU LOADING AND RENDERING LOGIC ---
    const loadMenuButton = document.getElementById('loadMenuButton');
    loadMenuButton.addEventListener('click', loadAndRenderMenu);

    async function loadAndRenderMenu() {
        setButtonLoading(loadMenuButton, true, 'Loading...');
        logStatus('Load Menu button clicked. Loading PRIVATE menu...');
        const menuContainer = document.getElementById('menuContainer');
        const loadingMsg = document.getElementById('loadingMessage');
        if (loadingMsg) loadingMsg.style.display = '';
        menuContainer.innerHTML = '';
        document.getElementById('editRestaurantName').value = '';
        document.getElementById('editRestaurantAddress').value = '';
        document.getElementById('editRestaurantPhone').value = '';
        document.getElementById('editComboNote').value = '';
        document.getElementById('editLunchNote').value = '';
        document.getElementById('editHoursLines').innerHTML = '';
        try {
            const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
            const snapshot = await getDocs(menuRef);
            if (snapshot.empty) {
                hideLoadingMessage();
                logStatus('No private menu data found.');
                setButtonLoading(loadMenuButton, false);
                return;
            }
            let menuItems = [];
            let infoDoc = null;
            snapshot.forEach(docSnap => {
                if (docSnap.id === '_info') {
                    infoDoc = docSnap.data();
                } else {
                    menuItems.push({ _id: docSnap.id, ...docSnap.data() });
                }
            });
            // keep a representation of the loaded private dataset so Normalize & Download can use it
            lastParsedDoc = { menuData: menuItems, info: infoDoc };
            menuItems.sort((a, b) => (a.categoryOrder - b.categoryOrder) || (a.itemOrder - b.itemOrder));
            if (infoDoc && infoDoc.restaurant) {
                document.getElementById('editRestaurantName').value = infoDoc.restaurant.name || '';
                document.getElementById('editRestaurantAddress').value = infoDoc.restaurant.address || infoDoc.restaurant.location || '';
                document.getElementById('editRestaurantPhone').value = infoDoc.restaurant.phone || '';
                const hoursLines = document.getElementById('editHoursLines');
                hoursLines.innerHTML = '';
                const useStructured = document.getElementById('useStructuredHours');
                const structuredBlock = document.getElementById('structuredHours');
                if (infoDoc.restaurant.hours) {
                    // If hours is an object keyed by days, populate structured controls
                    if (typeof infoDoc.restaurant.hours === 'object' && !Array.isArray(infoDoc.restaurant.hours)) {
                        if (useStructured) useStructured.checked = true;
                        if (structuredBlock) structuredBlock.style.display = '';
                        // fill rows
                        const rows = structuredBlock.querySelectorAll('.structured-hour-row');
                        rows.forEach(row => {
                            const day = row.getAttribute('data-day');
                            const openInput = row.querySelector('.hours-open');
                            const closeInput = row.querySelector('.hours-close');
                            const h = infoDoc.restaurant.hours[day];
                            if (h && typeof h === 'object') {
                                openInput.value = h.open || '';
                                closeInput.value = h.close || '';
                            } else {
                                openInput.value = '';
                                closeInput.value = '';
                            }
                        });
                    } else if (Array.isArray(infoDoc.restaurant.hours)) {
                        // array of lines: populate the free-text lines area
                        if (useStructured) useStructured.checked = false;
                        if (structuredBlock) structuredBlock.style.display = 'none';
                        infoDoc.restaurant.hours.forEach((line, idx) => {
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.className = 'block w-full text-base text-gray-700 bg-gray-50 rounded px-2 py-1 mb-1 max-w-xl';
                            input.value = line;
                            input.placeholder = 'Hours line';
                            input.dataset.idx = idx;
                            hoursLines.appendChild(input);
                        });
                    } else if (typeof infoDoc.restaurant.hours === 'string') {
                        if (useStructured) useStructured.checked = false;
                        if (structuredBlock) structuredBlock.style.display = 'none';
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'block w-full text-base text-gray-700 bg-gray-50 rounded px-2 py-1 mb-1 max-w-xl';
                        input.value = infoDoc.restaurant.hours;
                        input.placeholder = 'Hours line';
                        hoursLines.appendChild(input);
                    }
                }
            }
            if (infoDoc && infoDoc.notes) {
                document.getElementById('editComboNote').value = infoDoc.notes.combination_plate || infoDoc.notes.combo || '';
                document.getElementById('editLunchNote').value = infoDoc.notes.lunch_special || infoDoc.notes.lunch || '';
            }
            // Normalize items to ensure `unit` is an array of objects for rendering
            menuItems = menuItems.map(i => normalizeMenuItem(i));
            const groupedMenu = menuItems.reduce((acc, item) => {
                (acc[item.category] = acc[item.category] || []).push(item);
                return acc;
            }, {});
            for (const category in groupedMenu) {
                const items = groupedMenu[category];
                const firstItem = items[0] || {};
                const chineseName = firstItem.chinese_name || '';
                const note = firstItem.note || '';
                const card = document.createElement('div');
                card.className = 'menu-card mb-8';
                const headerDiv = document.createElement('div');
                headerDiv.className = 'category-header flex items-center';
                const catInput = document.createElement('input');
                catInput.type = 'text';
                catInput.value = category;
                catInput.className = 'text-2xl font-extrabold text-gray-900 bg-gray-50 rounded px-2 py-1';
                headerDiv.appendChild(catInput);
                const catChinese = document.createElement('input');
                catChinese.type = 'text';
                catChinese.value = chineseName;
                catChinese.className = 'text-lg text-gray-500 bg-gray-50 rounded px-2 py-1 ml-2';
                headerDiv.appendChild(catChinese);
                card.appendChild(headerDiv);
                if (note) {
                    const catNote = document.createElement('input');
                    catNote.type = 'text';
                    catNote.value = note;
                    catNote.className = 'w-full text-base text-yellow-700 bg-yellow-50 border-l-4 border-yellow-400 rounded-lg p-2 mb-2';
                    card.appendChild(catNote);
                }
                const ul = document.createElement('ul');
                ul.className = 'space-y-4';
                // Use helper to produce admin-friendly HTML for each item
                ul.innerHTML = items.map(it => buildAdminItemHtml(it)).join('');
                card.appendChild(ul);
                menuContainer.appendChild(card);
            }
            // Show the Save Menu row now that the menu is loaded
            const saveRow = document.getElementById('saveMenuBtnRow');
            if (saveRow) saveRow.style.display = '';
            hideLoadingMessage();
            logStatus('PRIVATE menu loaded.');
            setButtonLoading(loadMenuButton, false);
        } catch (err) {
            hideLoadingMessage();
            logStatus('Error loading menu: ' + (err.message || err));
            setButtonLoading(loadMenuButton, false);
        }
    }

    // Delete the entire PRIVATE menu from Firestore
    deleteButton.addEventListener('click', async () => {
        if (!db || !auth.currentUser) {
            statusMessage.textContent = 'You must be logged in as admin.';
            return;
        }
        setButtonLoading(deleteButton, true, 'Deleting...');
        try {
            logStatus('Deleting PRIVATE menu...');
            const menuRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
            const existingDocs = await getDocs(menuRef);
            const deleteBatch = writeBatch(db);
            existingDocs.forEach((doc) => {
                deleteBatch.delete(doc.ref);
            });
            await deleteBatch.commit();
            logStatus('PRIVATE menu deleted successfully!');
            setButtonLoading(deleteButton, false);
            loadMenuButton.click();
        } catch (error) {
            console.error("Error deleting menu:", error);
            logStatus(`Error deleting menu: ${error.message}`);
            setButtonLoading(deleteButton, false);
        }
    });

        // Publish button logic: copy private dataset to public
        const publishButton = document.getElementById('publishButton');
        publishButton.addEventListener('click', async () => {
            if (!db || !auth.currentUser) {
                logStatus('You must be logged in as admin.');
                return;
            }
            setButtonLoading(publishButton, true, 'Publishing...');
            try {
                logStatus('Publishing PRIVATE menu to PUBLIC...');
                const privateRef = collection(db, `artifacts/${appId}/private/data/menu_data_admin`);
                const publicRef = collection(db, `artifacts/${appId}/public/data/menu_data`);
                // Get all private docs
                const privateDocs = await getDocs(privateRef);
                if (privateDocs.empty) {
                    logStatus('No private menu data to publish. Aborting.');
                    setButtonLoading(publishButton, false);
                    return;
                }
                // Delete all public docs
                const publicDocs = await getDocs(publicRef);
                const deleteBatch = writeBatch(db);
                publicDocs.forEach((doc) => {
                    deleteBatch.delete(doc.ref);
                });
                await deleteBatch.commit();
                logStatus('All old public menu data deleted.');
                // Write all private docs to public (normalize items to avoid nested arrays)
                const publishBatch = writeBatch(db);
                privateDocs.forEach((docSnap) => {
                    const id = docSnap.id;
                    const raw = docSnap.data();
                    const newDocRef = id === '_info' ? doc(publicRef, '_info') : doc(publicRef);
                    if (id === '_info') {
                        // Info doc - write as-is
                        publishBatch.set(newDocRef, raw);
                    } else {
                        publishBatch.set(newDocRef, normalizeMenuItem(raw));
                    }
                });
                await publishBatch.commit();
                logStatus('Publish complete! Public menu updated.');
                setButtonLoading(publishButton, false);
            } catch (err) {
                logStatus('Error publishing menu: ' + (err.message || err));
                setButtonLoading(publishButton, false);
            }
        });
        
        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('[Admin] Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.warn('[Admin] Service Worker registration failed:', error);
                    });
            });
        }
</script>
</body>
</html>